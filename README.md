# Домашнее задание к занятию «Базы данных, их типы»

## ` Дмитрий Климов `

## Задание 1. СУБД
Кейс
Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.

1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?

1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.

1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?

1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?


## Ответ:

1.1. Бюджетирование проектов и финансовая аналитика:

Тип СУБД: Реляционная СУБД (RDBMS).
Почему: Для бюджетирования, финансовой отчетности и прогнозирования рисков необходима строгая структура данных, транзакционная целостность и поддержка сложных SQL-запросов. Реляционные СУБД, такие как PostgreSQL, Oracle Database или Microsoft SQL Server, идеально подходят для этих задач. Они обеспечивают ACID-транзакции (Atomicity, Consistency, Isolation, Durability), что критически важно для финансовых данных.
Реализация: Использовать хорошо спроектированную схему базы данных с нормализацией для предотвращения избыточности и обеспечения целостности. Применять сложные SQL-запросы для анализа и построения отчетов.

1.1. Хеширование стало занимать длительное время, какое API можно использовать для ускорения работы?* 
Для ускорения хеширования можно использовать аппаратное ускорение, если это возможно (например, аппаратные криптографические ускорители, доступные на некоторых серверах). Если нет, можно использовать специализированные библиотеки, написанные на C/C++, например, OpenSSL, и вызывать их из вашей основной СУБД через API (например, через пользовательские функции (UDF) в PostgreSQL). Важно профилировать текущий код, чтобы точно определить, что именно занимает больше всего времени, и оптимизировать именно это. Также стоит рассмотреть возможность использования более быстрых алгоритмов хеширования, если это допустимо с точки зрения безопасности.

1.2. Лендинги и CRM:

Тип СУБД для лендингов: NoSQL СУБД (например, MongoDB, Apache Cassandra).
Почему для лендингов: Для лендингов важна гибкость схемы, так как данные могут часто меняться. NoSQL СУБД позволяют быстро адаптироваться к новым типам данных без необходимости изменения схемы базы данных. Они также хорошо масштабируются для обработки большого количества посетителей.
Тип СУБД для CRM: Реляционная СУБД (RDBMS) или NoSQL СУБД (в зависимости от сложности CRM).
Почему для CRM: Если CRM требует сложной отчетности, связей между данными и транзакционной целостности, то лучше использовать реляционную СУБД. Если же CRM простая и требует только хранить данные лидов, то можно использовать NoSQL.

1.2. Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?*
Да, можно. MongoDB с использованием JSON документов подходит. Для лендингов можно хранить данные в JSON формате, а для CRM можно создать коллекции с определенной структурой, что даст гибкость и скорость.

1.3. База знаний по корпоративным нормам и правилам:

Тип СУБД: Графовая СУБД (например, Neo4j) или Document Store (например, MongoDB)
Почему: Если необходимо отображать связи между нормами, правилами, сотрудниками и отделами, то графовая СУБД идеально подходит. Если же просто необходимо хранить структурированные документы, то можно использовать Document Store.

1.3. Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?* 
Да, можно использовать MongoDB, если выбрали ее для лендингов и CRM. В этом случае корпоративные нормы и правила можно хранить в отдельных коллекциях в виде структурированных JSON-документов.

1.4. Логистика (формирование маршрутов и распределение курьеров):

Тип СУБД: Графовая СУБД (например, Neo4j) или Пространственная СУБД (PostGIS - расширение для PostgreSQL).
Почему: Для формирования оптимальных маршрутов и распределения курьеров важна возможность быстро работать с географическими данными и связями между объектами (адреса, курьеры, маршруты). Графовая СУБД позволяет эффективно находить кратчайшие пути, а пространственная СУБД позволяет выполнять сложные географические запросы.

1.4. Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?* 
Можно подключить отдел закупок к СУБД логистов, особенно если используется графовая или пространственная СУБД. Данные о закупках (поставщики, материалы, цены, сроки) можно связать с данными о логистике (объекты, маршруты, курьеры) для оптимизации поставок. Важно правильно спроектировать схему данных и настроить API для обмена информацией.

1.5. Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?*

Теоретически, да, можно. PostgreSQL с расширениями, такими как PostGIS, предоставляет возможности для решения большинства задач:

Реляционная база данных: Для бюджетирования, финансовой аналитики, и части CRM.
Пространственные данные (PostGIS): Для логистики и маршрутизации.
JSONB поддержка: Для гибкого хранения данных лендингов (аналогично NoSQL).
Графовые расширения (например, pg_featureserv): Для задач отдела контроля качества и более сложных связей в логистике, хотя это может быть менее эффективно, чем специализированная графовая СУБД.
Преимущества использования одной СУБД:

Упрощение администрирования и обслуживания.
Снижение затрат на лицензирование и инфраструктуру.
Облегчение интеграции данных между разными отделами.
Недостатки использования одной СУБД:

Возможные компромиссы в производительности для некоторых задач (например, графовые запросы в PostgreSQL могут быть медленнее, чем в Neo4j).
Сложность настройки и оптимизации СУБД для разных типов задач.
Вывод:

Выбор одной СУБД (PostgreSQL) - это компромисс между простотой и оптимальной производительностью для каждой задачи. Если производительность критична для определенных задач, то лучше использовать специализированные СУБД (например, Neo4j для логистики). Но для большинства задач PostgreSQL с расширениями будет достаточно хорошим решением.


## Задание 2. Транзакции

2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

## Ответ:

2.1. Пополнение баланса счёта телефона (успешная транзакция):

Инициация транзакции: Пользователь инициирует пополнение баланса телефона через приложение, сайт или другой интерфейс, указывая номер телефона и сумму пополнения. Система проверяет наличие достаточных средств на источнике (например, банковской карте или внутреннем счете пользователя в системе).
Авторизация: Система отправляет запрос в процессинговый центр (например, банка) для авторизации транзакции на указанную сумму. Процессинговый центр проверяет достаточность средств на карте/счете, лимиты и другие параметры безопасности.
Подтверждение авторизации: Процессинговый центр присылает подтверждение (или отклонение) авторизации. Если авторизация отклонена (например, недостаточно средств или превышен лимит), система уведомляет пользователя об ошибке и причинах.
Списание средств: Если авторизация подтверждена, система списывает средства с источника пользователя (например, блокирует сумму на банковской карте, списывает с внутреннего счета).
Зачисление средств: Система отправляет запрос оператору сотовой связи на пополнение баланса указанного номера телефона на указанную сумму. Оператор проверяет номер телефона и доступность сервиса.
Подтверждение зачисления: Оператор сотовой связи подтверждает зачисление средств на баланс телефона. Система уведомляет пользователя об успешном пополнении баланса.

2.1.* Автоплатёж (успешная транзакция):

В случае автоплатежа добавляются этапы, связанные с автоматическим запуском и проверкой условий:
Проверка условий автоплатежа: Система (например, банковское приложение или приложение оператора связи) периодически проверяет условия для запуска автоплатежа. Эти условия могут включать достижение определенного порога баланса на телефоне, наступление определенной даты, или комбинацию факторов.
Инициация транзакции (автоматически): Если условия автоплатежа соблюдены, система автоматически инициирует пополнение баланса телефона на предустановленную сумму. Система проверяет наличие достаточных средств на источнике (например, банковской карте или внутреннем счете пользователя в системе).
Авторизация: Система отправляет запрос в процессинговый центр (например, банка) для авторизации транзакции на указанную сумму. Процессинговый центр проверяет достаточность средств на карте/счете, лимиты и другие параметры безопасности. Как правило, для автоплатежей предварительно получается согласие пользователя на списание средств без дополнительной авторизации для каждой транзакции в рамках заданных лимитов и условий.
Подтверждение авторизации: Процессинговый центр присылает подтверждение (или отклонение) авторизации. Если авторизация отклонена, система пытается повторить транзакцию несколько раз (с заданным интервалом) или отправляет уведомление пользователю о проблеме.
Списание средств: Если авторизация подтверждена, система списывает средства с источника пользователя (например, блокирует сумму на банковской карте, списывает с внутреннего счета).
Зачисление средств: Система отправляет запрос оператору сотовой связи на пополнение баланса указанного номера телефона на указанную сумму. Оператор проверяет номер телефона и доступность сервиса. Важно отметить, что в случае автоплатежа, может быть использован механизм Direct Debit, когда оператор связи сам инициирует списание средств со счета пользователя, на основании предварительно полученного согласия.
Подтверждение зачисления: Оператор сотовой связи подтверждает зачисление средств на баланс телефона. Система уведомляет пользователя об успешном пополнении баланса. В случае Direct Debit, система также фиксирует факт списания средств.
Ключевые отличия автоплатежа:

Автоматическая инициация: Транзакция инициируется автоматически при соблюдении определенных условий.
Предварительное согласие: Пользователь дает предварительное согласие на автоматическое списание средств, а не подтверждает каждую транзакцию отдельно.
Повторные попытки: В случае неудачи (например, недостаточно средств) система может пытаться повторить транзакцию несколько раз.
Уведомления: Система уведомляет пользователя о совершенных автоплатежах.
Direct Debit: В некоторых случаях (особенно при прямой интеграции с оператором связи) может использоваться механизм Direct Debit, что упрощает и автоматизирует процесс списания средств.

## Задание 3. SQL vs NoSQL

3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.

3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

## Ответ:

## Преимущества SQL-систем по отношению к NoSQL:

ACID-транзакции: SQL-системы гарантируют ACID (Atomicity, Consistency, Isolation, Durability) свойства транзакций. Это означает, что каждая транзакция выполняется как единое целое (атомарность), данные остаются в согласованном состоянии (согласованность), транзакции изолированы друг от друга (изолированность), и изменения данных сохраняются надежно (долговечность). NoSQL-системы часто жертвуют ACID в пользу производительности и масштабируемости.
Сложные запросы: SQL (Structured Query Language) позволяет выполнять сложные запросы к данным с использованием объединений (joins), подзапросов, агрегатных функций и других мощных возможностей. NoSQL-системы обычно имеют более ограниченные возможности запросов.
Стандартизация: SQL является стандартизированным языком, что упрощает перенос приложений между различными SQL-системами. NoSQL-системы не имеют единого стандарта, что может затруднить перенос данных и логики между разными NoSQL-базами данных.
Зрелость экосистемы: SQL-системы существуют уже много лет, поэтому вокруг них сложилась зрелая экосистема инструментов, библиотек, фреймворков и специалистов. NoSQL-системы относительно новы, поэтому их экосистема менее развита.
Консистентность данных (сильная): SQL-системы обычно предлагают сильную консистентность данных, то есть все клиенты всегда видят одну и ту же актуальную версию данных. NoSQL-системы часто предлагают eventual consistency, что означает, что изменения данных могут быть видны клиентам с задержкой.

## Преимущества NewSQL перед SQL и NoSQL:

NewSQL системы, по моему мнению, пытаются объединить лучшее из обоих миров: масштабируемость и производительность NoSQL с ACID-транзакциями и консистентностью данных SQL. Вот их основные преимущества:

Масштабируемость и производительность, сравнимые с NoSQL:

NewSQL системы разработаны для горизонтального масштабирования на кластере серверов, как и NoSQL системы. Они стремятся обеспечить высокую пропускную способность и низкую задержку, необходимые для современных веб-приложений. В отличие от традиционных SQL баз, которые часто сталкиваются с проблемами масштабирования.

ACID-транзакции, как в SQL:

NewSQL системы поддерживают ACID-транзакции, что гарантирует целостность данных. Это критически важно для приложений, требующих высокой надежности, например, финансовых систем. Это основное отличие от NoSQL, который часто жертвует ACID ради масштабируемости.

SQL-совместимость (частичная или полная): 

Многие NewSQL системы предлагают SQL-совместимый интерфейс, что упрощает миграцию существующих SQL-приложений и позволяет использовать знакомые инструменты и навыки. Однако, они могут иметь некоторые ограничения в поддержке всего синтаксиса SQL.

Более предсказуемая производительность, чем у NoSQL: 

NewSQL системы стараются обеспечивать более предсказуемую производительность, чем NoSQL системы, за счет использования оптимизированных алгоритмов и структур данных. NoSQL часто жертвует предсказуемостью в пользу скорости в определенных операциях.

Меньше компромиссов между консистентностью и доступностью: 

NewSQL системы пытаются найти баланс между консистентностью и доступностью (CAP-теорема), предлагая варианты конфигурации, позволяющие выбирать приоритет. В то время как NoSQL часто делает явный выбор в пользу доступности (AP) или разделения (CP).

В целом, NewSQL представляет собой перспективное направление в развитии баз данных, которое может стать хорошим выбором для приложений, требующих и масштабируемости, и надежности. Однако, стоит учитывать, что NewSQL системы относительно новы, и их экосистема все еще находится в стадии развития. Кроме того, миграция на NewSQL может потребовать значительных усилий по перепроектированию архитектуры приложения.

## Задание 4. Кластеры

Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.

На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?

## Ответ:

Выбор СУБД и модели распределенных вычислений для обработки огромного количества данных на 1000 машинах – задача многофакторная. Ключевые критерии, которыми я буду руководствоваться, и обоснование выбора:

Критерии выбора СУБД:

Горизонтальная масштабируемость: Способность СУБД эффективно распределять данные и запросы между узлами кластера (машинами). Требуется архитектура, позволяющая добавлять новые узлы в кластер с минимальным влиянием на производительность.
Отказоустойчивость: Способность СУБД продолжать функционировать при выходе из строя отдельных узлов. Это достигается за счет репликации данных и автоматического переключения на резервные узлы.
Тип данных: Характер данных, которые предстоит обрабатывать. Если данные строго структурированы, хорошо подойдет реляционная СУБД. Если данные полуструктурированы или неструктурированы, стоит рассмотреть NoSQL СУБД.
Тип запросов: Характер запросов, которые будут выполняться к данным. Для сложных аналитических запросов, требующих JOIN’ов и агрегаций, лучше подойдут СУБД, оптимизированные для OLAP (Online Analytical Processing). Для простых операций чтения/записи лучше подойдут СУБД, оптимизированные для OLTP (Online Transaction Processing).
Сообщество и экосистема: Наличие активного сообщества, хорошей документации и широкого спектра инструментов для работы с СУБД.
Стоимость: Общая стоимость владения СУБД, включая стоимость лицензий, оборудования, поддержки и обслуживания.
Наиболее подходящая модель распределенных вычислений и почему:

Учитывая масштаб задачи (1000 машин) и необходимость обрабатывать “огромное количество данных”, наиболее подходящей моделью распределенных вычислений будет MapReduce.

Почему MapReduce?

Масштабируемость: MapReduce изначально разрабатывалась для обработки больших объемов данных на кластерах из тысяч машин. Она хорошо масштабируется горизонтально, позволяя распределять задачи между большим количеством узлов.
Отказоустойчивость: MapReduce обладает встроенными механизмами отказоустойчивости. В случае сбоя одного из узлов, задача будет автоматически перераспределена на другой узел.
Параллелизм: MapReduce позволяет распараллеливать вычисления, что значительно ускоряет обработку данных. Фазы “Map” и “Reduce” могут выполняться одновременно на разных узлах кластера.
Экосистема: MapReduce имеет развитую экосистему инструментов, таких как Apache Hadoop и Apache Spark, которые упрощают разработку и развертывание распределенных приложений. Apache Spark, в частности, предоставляет более гибкую и эффективную альтернативу классическому MapReduce для многих задач.
Подходит для batch-обработки: MapReduce хорошо подходит для пакетной обработки данных, когда данные обрабатываются большими порциями. Это типично для задач, связанных с большим объемом данных и сложными вычислениями.
Выбор конкретной СУБД (пример):

Предположим, что данные, которые необходимо обрабатывать, – это логи веб-сервера, и необходимо выполнять аналитические запросы для выявления трендов и аномалий. В этом случае я бы рассматривал следующие варианты:

Apache Hadoop с Hive/Impala/Spark SQL: Hadoop предоставляет платформу для хранения и обработки данных в распределенной файловой системе (HDFS). Hive и Impala предоставляют SQL-подобный интерфейс для работы с данными в HDFS, а Spark SQL обеспечивает более быструю и гибкую обработку данных. Это хороший вариант, если данные неструктурированы или полуструктурированы.
Google BigQuery: Облачный сервис аналитики данных, основанный на модели MapReduce. Он полностью управляется Google, что упрощает развертывание и обслуживание. Подходит, если нет необходимости в локальном решении.
ClickHouse: Это колоночная СУБД, оптимизированная для аналитических запросов (OLAP). Она обеспечивает очень высокую производительность и хорошо масштабируется горизонтально. ClickHouse подходит, если данные структурированы и требуется высокая скорость обработки запросов.
Итоговый выбор будет зависеть от конкретных требований к проекту, бюджета и доступных ресурсов. Необходимо провести тщательное тестирование и сравнение различных вариантов, чтобы выбрать наиболее подходящее решение. Важно также учитывать, что в современных реализациях, как правило, используются комбинации различных подходов, например, Spark для обработки и ClickHouse для хранения и анализа.
